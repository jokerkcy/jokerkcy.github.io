<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>刷题笔记</title>
      <link href="/2021/07/21/the-first-blog/"/>
      <url>/2021/07/21/the-first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode热门前100题"><a href="#Leetcode热门前100题" class="headerlink" title="Leetcode热门前100题"></a>Leetcode热门前100题</h1><span id="more"></span> <h2 id="Leetcode-10-正则表达式匹配"><a href="#Leetcode-10-正则表达式匹配" class="headerlink" title="Leetcode.10.正则表达式匹配"></a>Leetcode.10.正则表达式匹配</h2><p><img src="https://img-blog.csdnimg.cn/20210720171650777.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDAzNTI3MQ==,size_16,color_FFFFFF,t_70" alt="题目内容"></p><p>主要方法：动态规划</p><p>注意点1：当两个字符串都为0的时候也是可以匹配的，所以设置dp[0][0]为true。</p><p>字符串匹配主要分配三种情况：当前位置的字母相同，p当前位置字符为‘.’，以及p当前位置的字符为’*’。<br>前两种情况比较简单，可以直接用一个函数提取出来，简化代码</p><p>第三种情况就比较复杂，比较难以理解</p><p>状态转移的时候不要跳跃的去思考到还没有转移到遇到’<em>‘的情况，只看当前的位置。所以当前位置不是’</em>‘的时候只用考虑前两种匹配方式</p><p>当前位置是’*’的时候又分为两种情况：</p><p>一种是*前的字符与s中的字符不匹配：那么状态转移方程直接为dp[i][j]=dp[i][j-2]，这是比较好理解的</p><p>另一种是*前的字符与s中的字符匹配（这里的匹配包括’.’的匹配）：</p><p>1）p与s可以匹配1次：dp[i][j]=dp[i-1][j]，其中包含了可以匹配多次的意思，dp[i-1][j]也是当前位置为*的判断</p><p>2）p与s可以匹配0次：dp[i][j]=dp[i][j-2]，qbb与qbbb<em>前面b</em>前已经可以匹配了，所以需要匹配0次</p><p>从而就可以写出代码了</p><pre><code>class Solution &#123;    public boolean isMatch(String s, String p) &#123;        int m=s.length(),n=p.length();        boolean[][] dp = new boolean[m+1][n+1];        dp[0][0]=true;        for(int i=0;i&lt;=m;i++)&#123;            for(int j=1;j&lt;=n;j++)&#123;                if(p.charAt(j-1)!=&#39;*&#39;)&#123;                    dp[i][j]=match(s,p,i,j)&amp;&amp;dp[i-1][j-1];                &#125;else&#123;                    if(match(s,p,i,j-1))&#123;                        dp[i][j]=dp[i-1][j]||dp[i][j-2];                    &#125;else&#123;                        dp[i][j]=dp[i][j-2];                    &#125;                &#125;            &#125;        &#125;        return dp[m][n];    &#125;    public boolean match(String s,String p,int i,int j)&#123;        if(i&lt;=0)return false;        if(p.charAt(j-1)==&#39;.&#39;)return true;        return s.charAt(i-1)==p.charAt(j-1);    &#125;&#125;</code></pre><h2 id="Leetcode-32-最长有效括号"><a href="#Leetcode-32-最长有效括号" class="headerlink" title="Leetcode.32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">Leetcode.32. 最长有效括号</a></h2><p><img src="/2021/07/21/the-first-blog/blog\source_posts\image-20210728235425511.png" alt="image-20210728235425511"></p><p>方法一：动态规划</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n=s.length();</span><br><span class="line"><span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(chars[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(chars[i-<span class="number">1</span>]==<span class="string">&#x27;(&#x27;</span>) </span><br><span class="line">                    dp[i]=i-<span class="number">2</span>&gt;=<span class="number">0</span>?dp[i-<span class="number">2</span>]+<span class="number">2</span>:<span class="number">2</span>;</span><br><span class="line">                 <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-dp[i-<span class="number">1</span>]-<span class="number">2</span>&gt;=<span class="number">0</span>&amp;&amp;chars[i-dp[i-<span class="number">1</span>]-<span class="number">1</span>]==<span class="string">&#x27;(&#x27;</span>) </span><br><span class="line">                        dp[i]=dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>]+dp[i-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(i-dp[i-<span class="number">1</span>]-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;chars[i-dp[i-<span class="number">1</span>]-<span class="number">1</span>]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        dp[i]=<span class="number">2</span>+dp[i-<span class="number">1</span>];</span><br><span class="line">                    &#125;       </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> temp : dp) </span><br><span class="line"><span class="keyword">if</span>(temp&gt;res)res=temp;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化动态规划数组，当当前字符是左括号，不改变依旧为0</p><p>是右括号的时候有两种情况：1）左边相邻的字符是左括号，那么刚好凑成有效的完整括号，那么当前可以构成的最长的有效字符的长度为2+截止前面两个字符能够构成的长度，考虑左边边界。</p><p>2)左边相邻的字符是右括号，那么要考虑中间已经构成有效字符的长度的左边一个字符，即：i-dp[i-1]-1处的字符是否是左括号，如果是那么就可以在左边的长度+2，同时加上再前面相邻可以构成的字符，同样要考虑左边界。</p><p>方法二：双指针</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;(&#x27;</span>)left++;</span><br><span class="line">            <span class="keyword">else</span> right++;</span><br><span class="line">            <span class="keyword">if</span>(right==left)</span><br><span class="line">                res=Math.max(res,<span class="number">2</span>*right);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(right&gt;left)&#123;</span><br><span class="line">                left=<span class="number">0</span>;</span><br><span class="line">                right=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left=<span class="number">0</span>;right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=s.length()-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(j)==<span class="string">&#x27;(&#x27;</span>)left++;</span><br><span class="line">            <span class="keyword">else</span> right++;</span><br><span class="line">            <span class="keyword">if</span>(right==left)</span><br><span class="line">                res=Math.max(res,<span class="number">2</span>*left);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(right&lt;left)&#123;</span><br><span class="line">                left=<span class="number">0</span>;</span><br><span class="line">                right=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点：当左括号的数量等于右括号的数量时，一定能够构成一个有效的括号子串，所以记录左括号和右括号的数量，相等的时候可以得到当前位置的有效括号子串长度</p><p>当右括号的数量大于左括号的数量时，那么此时不能再与后面的字符串构成连接，所以左右括号的数量归零，重新计数</p><p>特殊情况“（（（（（）”此时不会有左右括号数量相同的时候，所有还要从右边再遍历一次</p><h2 id="Leetcode-39-组合总和"><a href="#Leetcode-39-组合总和" class="headerlink" title="Leetcode.39. 组合总和"></a>Leetcode.<a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h2><p>关键点：list的add添加的如果是引用对象那么添加的是地址值，所以如果添加列表的话，直接添加之后再修改会改变已添加列表的值，所以添加一个新构建的列表然后将值赋给新添加的列表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        int len = candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        if (len == 0) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(candidates, 0, len, target, path, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param candidates 候选数组</span><br><span class="line">     * @param begin      搜索起点</span><br><span class="line">     * @param len        冗余变量，是 candidates 里的属性，可以不传</span><br><span class="line">     * @param target     每减去一个元素，目标值变小</span><br><span class="line">     * @param path       从根结点到叶子结点的路径，是一个栈</span><br><span class="line">     * @param res        结果集列表</span><br><span class="line">     */</span><br><span class="line">    private void dfs(int[] candidates, int begin, int len, int target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res) &#123;</span><br><span class="line">        // target 为负数和 0 的时候不再产生新的孩子结点</span><br><span class="line">        if (target &lt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 重点理解这里从 begin 开始搜索的语意</span><br><span class="line">        for (int i = begin; i &lt; len; i++) &#123;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line"></span><br><span class="line">            // 注意：由于每一个元素可以重复使用，下一轮搜索的起点依然是 i，这里非常容易弄错</span><br><span class="line">            dfs(candidates, i, len, target - candidates[i], path, res);</span><br><span class="line"></span><br><span class="line">            // 状态重置</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Leetcode-42-接雨水"><a href="#Leetcode-42-接雨水" class="headerlink" title="Leetcode.42. 接雨水"></a>Leetcode.<a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></h2><p>双指针</p><p>观察每一列可以接到的雨水数量与左右两边的最大值有关，可以遍历找到左右的最大值，计算当前列的雨水数，可以通过动态规划得到当前位置左右最大的列的值的动态数组，也可以使用双指针去优化内存空间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>,right=height.length-<span class="number">2</span>,sum=<span class="number">0</span>,maxleft=<span class="number">0</span>,maxright=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;height.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left-<span class="number">1</span>]&lt;height[right+<span class="number">1</span>])&#123;</span><br><span class="line">                maxleft=Math.max(maxleft,height[left-<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(height[left]&lt;maxleft)&#123;</span><br><span class="line">                    sum+=maxleft-height[left];</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxright=Math.max(maxright,height[right+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(height[right]&lt;maxright)&#123;</span><br><span class="line">                    sum+=maxright-height[right];</span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Leetcode-49-字母异位词分组"><a href="#Leetcode-49-字母异位词分组" class="headerlink" title="Leetcode.49. 字母异位词分组"></a>Leetcode.<a href="https://leetcode-cn.com/problems/group-anagrams/">49. 字母异位词分组</a></h2><p>先对字符串排序，然后通过Map查看具有想用元素的列表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] array = str.toCharArray();</span><br><span class="line">            Arrays.sort(array);</span><br><span class="line">            String key = <span class="keyword">new</span> String(array);</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马乐优商城笔记记录</title>
      <link href="/2021/07/21/%E9%BB%91%E9%A9%AC%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/07/21/%E9%BB%91%E9%A9%AC%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库设计——分库分表"><a href="#数据库设计——分库分表" class="headerlink" title="数据库设计——分库分表"></a>数据库设计——分库分表</h3><p>出现问题1：1153 Got a packet bigger than ‘max_allowed_packet’ bytes</p><p>解决方法：</p><p>在mysql命令行中修改</p><p>在mysql 命令行中运行:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global max_allowed_packet = 2*1024*1024*10</span><br><span class="line">注意：</span><br><span class="line">这样修改会报错：mysql&gt; set  max_allowed_packet=16MB;</span><br><span class="line">ERROR 1232 (42000): Incorrect argument type to variable &#x27;max_allowed_packet&#x27;</span><br></pre></td></tr></table></figure><p>然后退出命令行，重启mysql服务，再进入。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
